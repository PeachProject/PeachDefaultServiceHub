#This script has been generated by Peach Generator 1.
#Rerunning Peach Generator on this script will lead to a loss of your added python code.

def start(c, python_module, input_values, f, m):
    import ServiceUtility
    import os
    import time
    import shutil
    import tarfile
    import hashlib
    import sys
    import traceback

    ServiceUtility.info(c, "Generating unique temp output dir...")

    unique_relative_output_dir = "output_" + str(time.time()).replace(".", "")
    dir_path = os.path.dirname(os.path.realpath(__file__))
    unique_output_dir = os.path.join(dir_path, unique_relative_output_dir)
    os.makedirs(unique_output_dir)

    ServiceUtility.info(c, "Generated unique temp output dir '{}'".format(unique_relative_output_dir))

    ServiceUtility.info(c, "Generating cryptic folder name from original python module name...")

    new_folder_name = hashlib.md5(python_module.encode()).hexdigest()
    new_tar_name = "{}.tar".format(new_folder_name)

    ServiceUtility.info(c, "New cryptic tar name is '{}'".format(new_tar_name))

    new_folder_path = os.path.join(unique_output_dir, new_folder_name)
    python_tar_to_use = os.path.join(unique_output_dir, new_tar_name)

    ServiceUtility.info(c, "Copying python module to '{}'".format(new_tar_name))

    shutil.copyfile(python_module, python_tar_to_use)

    ServiceUtility.info(c, "Extracting tar '{}'".format(new_tar_name))
    
    tar = tarfile.open(python_tar_to_use)
    tar.extractall(path=new_folder_path)

    ServiceUtility.info(c, "Successfully extracted tar!")
    
    #We have successfully extracted the given tar...
    #Now we want to import the given module dynamically

    ServiceUtility.info(c, "Creating simulated node identifier values and generate input")
    #c variable consists of node id and primary key of workflow.
    #We wanna change the node id so that later on the output variables
    #can be identified properly.
    new_c = list(c)
    new_c[1] = c[1] + "_custom_script"
    ServiceUtility.info(c, "Simulated node idenfication values: '{}'".format(new_c))

    final_input = [new_c]
    final_input = final_input + input_values #add it to the input values and we're ready to go



    ServiceUtility.info(c, "Appending sys path and importing module '{}' and calling method '{}' ('{}.{}')".format(f, m, f, m))
    sys.path.append(new_folder_path)
    
    try:
        module = __import__(f)
        method = getattr(module, m)
        
        output = method(*final_input) # '*' makes the array being "real" separate parameters
        #Let's hope everything in the output was made available properly and we can return it safely
    except Exception as e:
        ServiceUtility.info(c, "Error when calling given method: {}".format(traceback.format_exc()))

    final_output = []
    if len(output) == 1:
        final_output.append([output])
    else:
        final_output.append(output)

    ServiceUtility.info(c, "Python Executor finished running...")
    ServiceUtility.info(c, "Python method returned {} values. They will be bundled and transferred to next service.".format(str(len(output))))
    ServiceUtility.info(c, "Removing temp output dir")

    try:
        shutil.rmtree(unique_output_dir)
        ServiceUtility.info(c, "Successfully removed temp output dir '{}'".format(unique_relative_output_dir))
    except Exception as e:
        ServiceUtility.error(c, "Error when removing temporary output dir... {}".format(traceback.format_exc()))


    return final_output
