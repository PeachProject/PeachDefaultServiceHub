#This script has been generated by Peach Generator 1.
#Rerunning Peach Generator on this script will lead to a loss of your added python code.

def start(c, python_module, input_values, f, m):
    import ServiceUtility
    import os
    import time
    import shutil
    
    import hashlib
    import sys
    import traceback

    print("==== PYTHON EXECUTOR!!!! ======")

    ServiceUtility.info(c, "Generating unique temp output dir...")

    unique_relative_output_dir = "output_" + str(time.time()).replace(".", "")
    dir_path = os.path.dirname(os.path.realpath(__file__))
    unique_output_dir = os.path.join(dir_path, unique_relative_output_dir)
    os.makedirs(unique_output_dir)

    ServiceUtility.info(c, "Generated unique temp output dir '{}'".format(unique_relative_output_dir))

    ServiceUtility.info(c, "Generating cryptic folder name from original python module name...")

    new_folder_name = hashlib.md5(python_module.encode()).hexdigest()
    filename, file_extension = os.path.splitext(python_module)
    new_file_name = "{}{}".format(new_folder_name, file_extension)

    ServiceUtility.info(c, "New cryptic {} name is '{}'".format(file_extension, new_file_name))

    new_folder_path = os.path.join(unique_output_dir, new_folder_name)
    python_archive_to_use = os.path.join(unique_output_dir, new_file_name)

    ServiceUtility.info(c, "Copying python module to '{}'".format(new_file_name))

    shutil.copyfile(python_module, python_archive_to_use)

    ServiceUtility.info(c, "Extracting {} '{}'".format(file_extension, new_file_name))
    
    extract(file_extension, python_archive_to_use, new_folder_path)

    ServiceUtility.info(c, "Successfully extracted archive!")
    
    #We have successfully extracted the given tar...
    #Now we want to import the given module dynamically

    ServiceUtility.info(c, "Creating simulated node identifier values and generate input")
    #c variable consists of node id and primary key of workflow.
    #We wanna change the node id so that later on the output variables
    #can be identified properly.
    new_c = list(c)
    new_c[1] = c[1] + "_custom_script"
    ServiceUtility.info(c, "Simulated node idenfication values: '{}'".format(new_c))

    final_input = [new_c]
    final_input = final_input + input_values #add it to the input values and we're ready to go



    ServiceUtility.info(c, "Appending sys path and importing module '{}' and calling method '{}' ('{}.{}')".format(f, m, f, m))
    sys.path.append(new_folder_path)
    
    try:
        module = __import__(f)
        method = getattr(module, m)
        
        output = method(*final_input) # '*' makes the array being "real" separate parameters
        #Let's hope everything in the output was made available properly and we can return it safely
    except Exception as e:
        ServiceUtility.info(c, "Error when calling given method: {}".format(traceback.format_exc()))

    final_output = []
    if len(output) == 1:
        final_output.append([output])
    else:
        final_output.append(output)

    ServiceUtility.info(c, "Python Executor finished running...")
    ServiceUtility.info(c, "Python method returned {} values. They will be bundled and transferred to next service.".format(str(len(output))))
    ServiceUtility.info(c, "Removing temp output dir")

    try:
        shutil.rmtree(unique_output_dir)
        ServiceUtility.info(c, "Successfully removed temp output dir '{}'".format(unique_relative_output_dir))
    except Exception as e:
        ServiceUtility.error(c, "Error when removing temporary output dir... {}".format(traceback.format_exc()))


    return final_output

def extract(extension, python_archive_to_use, new_folder_path):
    if extension.lower() == ".zip":
        unzip_module(python_archive_to_use, new_folder_path)
    else:
        untar_module(python_archive_to_use, new_folder_path)

def untar_module(python_archive_to_use, new_folder_path):
    import tarfile
    tar = tarfile.open(python_archive_to_use)
    tar.extractall(path=new_folder_path)

def unzip_module(python_archive_to_use, new_folder_path):
    import zipfile
    zip_ref = zipfile.ZipFile(python_archive_to_use, 'r')
    zip_ref.extractall(new_folder_path)
    zip_ref.close()